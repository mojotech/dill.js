// Generated by CoffeeScript 1.7.1
var __slice = [].slice;

module.exports = function() {
  var flowStep, _After, _Before;
  this.logger = require('./logger');
  this.timeout = 5000;
  this.visit = (function(_this) {
    return function(path) {
      return _this.driver.get("" + _this.host + path);
    };
  })(this);
  _Before = this.Before;
  _After = this.After;
  this._inFlow = function(code, callback) {
    return $.createFlow((function(_this) {
      return function(flow) {
        return flow.execute(function() {
          return code.call(_this);
        });
      };
    })(this)).then(_.partial(callback, null), function(err) {
      throw err;
    });
  };
  this.Before = function(code) {
    return _Before((function(_this) {
      return function(callback) {
        return _this._inFlow(code, callback);
      };
    })(this));
  };
  this.After = function(code) {
    return _After((function(_this) {
      return function(callback) {
        return _this._inFlow(code, callback);
      };
    })(this));
  };
  this.BeforeAll = function(code) {
    if (!this._ranBeforeAll) {
      this._ranBeforeAll = true;
      return this.Before(code);
    }
  };
  this.AfterAll = function(code) {
    if (!this._ranAfterAll) {
      this._ranAfterAll = true;
      return this.After(code);
    }
  };
  flowStep = (function(_this) {
    return function(code, args, successCallback, errCallback) {
      return $.createFlow(function(flow) {
        return flow.execute(function() {
          return code.apply(_this, args);
        });
      }).then(_.partial(successCallback, null), errCallback);
    };
  })(this);
  this.Given = this.When = (function(_this) {
    return function(pattern, code) {
      return _this.defineStep(pattern, function() {
        var args, callback, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        _this.lastStepType = 'Given';
        return flowStep(code, args, callback, callback);
      });
    };
  })(this);
  this.Then = (function(_this) {
    return function(pattern, code) {
      return _this.defineStep(pattern, function() {
        var args, callback, callforth, start, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        _this.lastStepType = 'Then';
        start = new Date;
        callforth = function() {
          return flowStep(code, args, callback, function(error) {
            if (new Date - start > _this.timeout) {
              return callback(error);
            } else {
              return $.delayed(1000).then(function() {
                return callforth();
              });
            }
          });
        };
        return callforth();
      });
    };
  })(this);
  this.And = (function(_this) {
    return function(pattern, code) {
      return _this[_this.lastStepType](pattern, code);
    };
  })(this);
  this.Before(function() {
    this.lastStepType = 'Given';
    return this.driver = new Driver.Builder().withCapabilities(Driver.Capabilities.chrome()).build();
  });
  return this.After(function() {
    this.driver.close();
    return this.driver.quit();
  });
};
